{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@taiga-ui/cdk/date-time/date-time.ts","ng://@taiga-ui/cdk/date-time/year.ts","ng://@taiga-ui/cdk/date-time/month.ts","ng://@taiga-ui/cdk/date-time/day.ts","ng://@taiga-ui/cdk/date-time/days.const.ts","ng://@taiga-ui/cdk/date-time/month-range.ts","ng://@taiga-ui/cdk/date-time/day-range.ts","ng://@taiga-ui/cdk/date-time/date-fillers.ts","ng://@taiga-ui/cdk/date-time/time.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","RANGE_SEPARATOR_CHAR","CHAR_NO_BREAK_SPACE","CHAR_EN_DASH","TuiYear","year","tuiAssert","assert","isValidYear","defineProperty","padStart","toString","isLeapYear","getAbsoluteLeapYears","getYearStartDaysOffset","absoluteLeapYears","yearBefore","_a","yearSameOrBefore","yearSame","yearSameOrAfter","yearAfter","append","backwards","_b","Number","isInteger","resultYear","formattedYear","toJSON","inRange","MAX_YEAR","Math","ceil","lengthBetween","from","to","normalizeYearPart","normalizeToIntNumber","TuiMonth","month","_this","_super","call","isValidMonth","formattedMonthPart","monthStartDaysOffset","daysCount","getMonthDaysCount","result","yearStartDaysOffset","currentMonth","monthBefore","another","monthSameOrBefore","monthSame","monthSameOrAfter","monthAfter","_c","totalMonths","floor","formattedMonth","toLocalNativeDate","Date","toUtcNativeDate","UTC","isValidMonthPart","currentLocal","nativeDate","getFullYear","getMonth","currentUtc","getUTCFullYear","getUTCMonth","absoluteFrom","normalizeMonthPart","MAX_MONTH","TuiDay","day","isValidDay","formattedDayPart","dayOfWeek","startFromMonday","getDay","dayBefore","daySameOrBefore","daySame","daySameOrAfter","dayAfter","dayLimit","min","max","_d","years","months","days","formattedDay","fromLocalNativeDate","date","getDate","fromUtcNativeDate","getUTCDate","getDayFromMonthRowCol","row","col","normalizeOf","normalizedYear","normalizedMonth","normalizedDay","normalizeDayPart","round","getTime","normalizeParse","yearMonthDayString","parseInt","slice","jsonParse","Error","monthDaysCount","TUI_FIRST_DAY","TUI_LAST_DAY","TuiMonthRange","sort","month1","month2","TuiDayRange","day1","day2","rangeString","dateFiller","dateRangeFiller","leftDay","length","TUI_DATE_FILLER","InjectionToken","factory","TUI_DATE_RANGE_FILLER","inject","TuiTime","hours","minutes","seconds","ms","isValidTime","shift","_e","newMs","secondsToAdd","newSeconds","minutesToAdd","newMinutes","hoursToAdd","mode","needAddMs","needAddSeconds","formatTime","toAbsoluteMilliseconds","MILLISECONDS_IN_MINUTE","MILLISECONDS_IN_SECOND","current","fromAbsoluteMilliseconds","now","MILLISECONDS_IN_HOUR","getTimezoneOffset","milliseconds","fromString","time","digits"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {CHAR_EN_DASH, CHAR_NO_BREAK_SPACE} from '@taiga-ui/cdk/constants';\n\nexport const DAYS_IN_WEEK = 7;\n\nexport const DAYS_IN_NORMAL_YEAR = 365;\n\nexport const DAYS_IN_LEAP_YEAR = 366;\n\nexport const MONTHS_IN_YEAR = 12;\n\nexport const MIN_DAY = 1;\n\nexport const MIN_MONTH = 0;\n\nexport const MAX_MONTH = 11;\n\nexport const MIN_YEAR = 0;\n\nexport const MAX_YEAR = 9999;\n\nexport const RANGE_SEPARATOR_CHAR = `${CHAR_NO_BREAK_SPACE}${CHAR_EN_DASH}${CHAR_NO_BREAK_SPACE}`;\n\nexport const MILLISECONDS_IN_SECOND = 1000;\n\nexport const SECONDS_IN_MINUTE = 60;\n\nexport const MINUTES_IN_HOUR = 60;\n\nexport const HOURS_IN_DAY = 24;\n\nexport const MILLISECONDS_IN_MINUTE = MILLISECONDS_IN_SECOND * SECONDS_IN_MINUTE;\n\nexport const MILLISECONDS_IN_HOUR = MILLISECONDS_IN_MINUTE * MINUTES_IN_HOUR;\n\nexport const MILLISECONDS_IN_DAY = MILLISECONDS_IN_HOUR * HOURS_IN_DAY;\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\nimport {TuiYearLike} from '@taiga-ui/cdk/interfaces';\nimport {padStart} from '@taiga-ui/cdk/utils/format';\nimport {inRange, normalizeToIntNumber} from '@taiga-ui/cdk/utils/math';\nimport {\n    DAYS_IN_LEAP_YEAR,\n    DAYS_IN_NORMAL_YEAR,\n    DAYS_IN_WEEK,\n    MAX_YEAR,\n    MIN_YEAR,\n} from './date-time';\n\n/**\n * Immutable year object\n * @nosideeffects\n */\nexport class TuiYear implements TuiYearLike {\n    constructor(readonly year: number) {\n        tuiAssert.assert(TuiYear.isValidYear(year));\n    }\n\n    get formattedYear(): string {\n        return padStart(this.year.toString(), 4, '0');\n    }\n\n    get isLeapYear(): boolean {\n        return TuiYear.isLeapYear(this.year);\n    }\n\n    /**\n     * Returns amount of leap years from year 0 to current\n     */\n    get absoluteLeapYears(): number {\n        return TuiYear.getAbsoluteLeapYears(this.year);\n    }\n\n    /**\n     * Returns day of week offset of the beginning of the current year\n     */\n    get yearStartDaysOffset(): number {\n        return TuiYear.getYearStartDaysOffset(this.year, this.absoluteLeapYears);\n    }\n\n    /**\n     * Passed year is after current\n     */\n    yearBefore({year}: TuiYear): boolean {\n        return this.year < year;\n    }\n\n    /**\n     * Passed year is the same or after current\n     */\n    yearSameOrBefore({year}: TuiYear): boolean {\n        return this.year <= year;\n    }\n\n    /**\n     * Passed year is the same as current\n     */\n    yearSame({year}: TuiYear): boolean {\n        return this.year === year;\n    }\n\n    /**\n     * Passed year is either the same of before the current\n     */\n    yearSameOrAfter({year}: TuiYear): boolean {\n        return this.year >= year;\n    }\n\n    /**\n     * Passed year is before current\n     */\n    yearAfter({year}: TuiYear): boolean {\n        return this.year > year;\n    }\n\n    // TODO: Consider removing `backwards` option\n    /**\n     * Immutably offsets year\n     */\n    append({year = 0}: TuiYearLike, backwards: boolean = false): TuiYear {\n        tuiAssert.assert(Number.isInteger(year));\n\n        if (backwards) {\n            year *= -1;\n        }\n\n        const resultYear = this.year + year;\n\n        tuiAssert.assert(TuiYear.isValidYear(resultYear));\n\n        return new TuiYear(resultYear);\n    }\n\n    toString(): string {\n        return this.formattedYear;\n    }\n\n    toJSON(): string {\n        return this.formattedYear;\n    }\n\n    /**\n     * Checks year for validity\n     */\n    static isValidYear(year: number): boolean {\n        return Number.isInteger(year) && inRange(year, MIN_YEAR, MAX_YEAR + 1);\n    }\n\n    /**\n     * Check if passed year is a leap year\n     */\n    static isLeapYear(year: number): boolean {\n        tuiAssert.assert(TuiYear.isValidYear(year));\n\n        return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);\n    }\n\n    /**\n     * Returns amount of leap years from year 0 to the passed one\n     */\n    static getAbsoluteLeapYears(year: number): number {\n        tuiAssert.assert(TuiYear.isValidYear(year));\n\n        return Math.ceil(year / 400) + (Math.ceil(year / 4) - Math.ceil(year / 100));\n    }\n\n    /**\n     * Returns day of week offset of the beginning of the passed year\n     *\n     * @param year\n     * @param absoluteLeapYears amount of leap years prior to the passed one\n     * @return offset in days\n     */\n    static getYearStartDaysOffset(year: number, absoluteLeapYears: number): number {\n        tuiAssert.assert(TuiYear.isValidYear(year));\n        tuiAssert.assert(Number.isInteger(absoluteLeapYears));\n        tuiAssert.assert(year >= absoluteLeapYears);\n        tuiAssert.assert(absoluteLeapYears >= 0);\n\n        return (\n            (absoluteLeapYears * DAYS_IN_LEAP_YEAR +\n                (year - absoluteLeapYears) * DAYS_IN_NORMAL_YEAR +\n                5) %\n            DAYS_IN_WEEK\n        );\n    }\n\n    static lengthBetween(from: TuiYear, to: TuiYear): number {\n        return to.year - from.year;\n    }\n\n    /**\n     * Normalizes year by clamping it between min and max years\n     */\n    protected static normalizeYearPart(year: number): number {\n        return normalizeToIntNumber(year, MIN_YEAR, MAX_YEAR);\n    }\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\nimport {TuiMonthNumber} from '@taiga-ui/cdk/enums';\nimport {TuiMonthLike} from '@taiga-ui/cdk/interfaces';\nimport {padStart} from '@taiga-ui/cdk/utils/format';\nimport {inRange, normalizeToIntNumber} from '@taiga-ui/cdk/utils/math';\nimport {DAYS_IN_WEEK, MAX_MONTH, MIN_MONTH, MONTHS_IN_YEAR} from './date-time';\nimport {TuiYear} from './year';\n\n/**\n * Immutable object consisting of year and month\n */\nexport class TuiMonth extends TuiYear implements TuiMonthLike {\n    /**\n     * @param year\n     * @param month (starting with 0)\n     */\n    constructor(year: number, readonly month: number) {\n        super(year);\n        tuiAssert.assert(TuiMonth.isValidMonth(year, month));\n    }\n\n    get formattedMonthPart(): string {\n        return padStart((this.month + 1).toString(), 2, '0');\n    }\n\n    /**\n     * Formatter month and year\n     */\n    get formattedMonth(): string {\n        return `${this.formattedMonthPart}.${this.formattedYear}`;\n    }\n\n    /**\n     * Calculates number of weeks in a month (counting non-full weeks)\n     */\n    get weeksRowsCount(): number {\n        return Math.ceil((this.monthStartDaysOffset + this.daysCount) / DAYS_IN_WEEK);\n    }\n\n    /**\n     * Returns days in a month\n     */\n    get daysCount(): number {\n        return TuiMonth.getMonthDaysCount(this.month, this.isLeapYear);\n    }\n\n    /**\n     * Computes day of week offset of the beginning of the month\n     */\n    get monthStartDaysOffset(): number {\n        let result = this.yearStartDaysOffset;\n\n        for (let currentMonth = 0; currentMonth <= this.month - 1; currentMonth++) {\n            result += TuiMonth.getMonthDaysCount(currentMonth, this.isLeapYear);\n        }\n\n        return result % DAYS_IN_WEEK;\n    }\n\n    /**\n     * Passed month and year are after current\n     */\n    monthBefore(another: TuiMonth): boolean {\n        return (\n            this.yearBefore(another) ||\n            (this.yearSame(another) && this.month < another.month)\n        );\n    }\n\n    /**\n     * Passed month and year are after or the same as current\n     */\n    monthSameOrBefore(another: TuiMonth): boolean {\n        return (\n            this.yearBefore(another) ||\n            (this.yearSame(another) && this.month <= another.month)\n        );\n    }\n\n    /**\n     * Passed month and year are the same as current\n     */\n    monthSame(another: TuiMonth): boolean {\n        return this.yearSame(another) && this.month === another.month;\n    }\n\n    /**\n     * Passed month and year are either before or equal to current\n     */\n    monthSameOrAfter(another: TuiMonth): boolean {\n        return (\n            this.yearAfter(another) ||\n            (this.yearSame(another) && this.month >= another.month)\n        );\n    }\n\n    /**\n     * Passed month and year are before current\n     */\n    monthAfter(another: TuiMonth): boolean {\n        return (\n            this.yearAfter(another) ||\n            (this.yearSame(another) && this.month > another.month)\n        );\n    }\n\n    // TODO: Consider removing `backwards` option\n    /**\n     * Immutably alters current month and year by passed offset\n     *\n     * @param offset\n     * @param backwards shift date backwards\n     * @return new month and year object as a result of offsetting current\n     */\n    append({year = 0, month = 0}: TuiMonthLike, backwards: boolean = false): TuiMonth {\n        if (backwards) {\n            year *= -1;\n            month *= -1;\n        }\n\n        const totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;\n\n        return new TuiMonth(\n            Math.floor(totalMonths / MONTHS_IN_YEAR),\n            totalMonths % MONTHS_IN_YEAR,\n        );\n    }\n\n    toString(): string {\n        return this.formattedMonth;\n    }\n\n    toJSON(): string {\n        return `${super.toJSON()}-${this.formattedMonthPart}`;\n    }\n\n    /**\n     * Returns native {@link Date} based on local time zone\n     */\n    toLocalNativeDate(): Date {\n        return new Date(this.year, this.month);\n    }\n\n    /**\n     * Returns native {@link Date} based on UTC\n     */\n    toUtcNativeDate(): Date {\n        return new Date(Date.UTC(this.year, this.month));\n    }\n\n    /**\n     * Tests month and year for validity\n     */\n    static isValidMonth(year: number, month: number): boolean {\n        return TuiYear.isValidYear(year) && TuiMonth.isValidMonthPart(month);\n    }\n\n    /**\n     * Returns number of days in a month\n     */\n    static getMonthDaysCount(month: number, isLeapYear: boolean): number {\n        tuiAssert.assert(TuiMonth.isValidMonthPart(month));\n\n        switch (month) {\n            case TuiMonthNumber.February:\n                return isLeapYear ? 29 : 28;\n            case TuiMonthNumber.April:\n            case TuiMonthNumber.June:\n            case TuiMonthNumber.September:\n            case TuiMonthNumber.November:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Returns current month and year based on local time zone\n     * @nosideeffects\n     */\n    static currentLocal(): TuiMonth {\n        const nativeDate = new Date();\n\n        return new TuiMonth(nativeDate.getFullYear(), nativeDate.getMonth());\n    }\n\n    /**\n     * Returns current month and year based on UTC\n     */\n    static currentUtc(): TuiMonth {\n        const nativeDate = new Date();\n\n        return new TuiMonth(nativeDate.getUTCFullYear(), nativeDate.getUTCMonth());\n    }\n\n    static lengthBetween(from: TuiMonth, to: TuiMonth): number {\n        const absoluteFrom = from.month + from.year * 12;\n        const absoluteTo = to.month + to.year * 12;\n\n        return absoluteTo - absoluteFrom;\n    }\n\n    /**\n     * Normalizes number by clamping it between min and max month\n     */\n    protected static normalizeMonthPart(month: number): number {\n        return normalizeToIntNumber(month, MIN_MONTH, MAX_MONTH);\n    }\n\n    /**\n     * Tests month for validity\n     */\n    private static isValidMonthPart(month: number): boolean {\n        return Number.isInteger(month) && inRange(month, MIN_MONTH, MAX_MONTH + 1);\n    }\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\nimport {TuiMonthNumber} from '@taiga-ui/cdk/enums';\nimport {TuiDayLike} from '@taiga-ui/cdk/interfaces';\nimport {padStart} from '@taiga-ui/cdk/utils/format';\nimport {inRange, normalizeToIntNumber} from '@taiga-ui/cdk/utils/math';\nimport {DAYS_IN_WEEK, MIN_DAY, MONTHS_IN_YEAR} from './date-time';\nimport {TuiMonth} from './month';\nimport {TuiYear} from './year';\n\n// TODO: Localized formatting\n/**\n * Immutable date object, consisting of day, month and year\n */\nexport class TuiDay extends TuiMonth {\n    constructor(year: number, month: number, readonly day: number) {\n        super(year, month);\n        tuiAssert.assert(TuiDay.isValidDay(year, month, day));\n    }\n\n    get formattedDayPart(): string {\n        return padStart(this.day.toString(), 2, '0');\n    }\n\n    /**\n     * Formatted whole date\n     */\n    get formattedDay(): string {\n        return `${this.formattedDayPart}.${this.formattedMonth}`;\n    }\n\n    /**\n     * Returns day of week\n     *\n     * @param startFromMonday whether week starts from Monday and not from Sunday\n     * @return day of week (from 0 to 6)\n     */\n    dayOfWeek(startFromMonday: boolean = true): number {\n        const dayOfWeek = startFromMonday\n            ? this.toLocalNativeDate().getDay() - 1\n            : this.toLocalNativeDate().getDay();\n\n        return dayOfWeek < 0 ? 6 : dayOfWeek;\n    }\n\n    /**\n     * Passed date is after current\n     */\n    dayBefore(another: TuiDay): boolean {\n        return (\n            this.monthBefore(another) ||\n            (this.monthSame(another) && this.day < another.day)\n        );\n    }\n\n    /**\n     * Passed date is after or equals to current\n     */\n    daySameOrBefore(another: TuiDay): boolean {\n        return (\n            this.monthBefore(another) ||\n            (this.monthSame(another) && this.day <= another.day)\n        );\n    }\n\n    /**\n     * Passed date is the same as current\n     */\n    daySame(another: TuiDay): boolean {\n        return this.monthSame(another) && this.day === another.day;\n    }\n\n    /**\n     * Passed date is either before or the same as current\n     */\n    daySameOrAfter(another: TuiDay): boolean {\n        return (\n            this.monthAfter(another) ||\n            (this.monthSame(another) && this.day >= another.day)\n        );\n    }\n\n    /**\n     * Passed date is before current\n     */\n    dayAfter(another: TuiDay): boolean {\n        return (\n            this.monthAfter(another) ||\n            (this.monthSame(another) && this.day > another.day)\n        );\n    }\n\n    /**\n     * Clamping date between two limits\n     *\n     * @param min\n     * @param max\n     * @return clamped date\n     */\n    dayLimit(min: TuiDay | null, max: TuiDay | null): TuiDay {\n        if (min !== null && this.dayBefore(min)) {\n            return min;\n        }\n\n        if (max !== null && this.dayAfter(max)) {\n            return max;\n        }\n\n        return this;\n    }\n\n    // TODO: Consider removing `backwards` option\n    /**\n     * Immutably alters current day by passed offset\n     *\n     * If resulting month has more days than original one, date is rounded to the maximum day\n     * in the resulting month. Offset of days will be calculated based on the resulted year and month\n     * to not interfere with parent classes methods\n     *\n     * @param offset\n     * @param backwards shift date backwards\n     * @return new date object as a result of offsetting current\n     */\n    append(\n        {year = 0, month = 0, day = 0}: TuiDayLike,\n        backwards: boolean = false,\n    ): TuiDay {\n        if (backwards) {\n            year *= -1;\n            month *= -1;\n            day *= -1;\n        }\n\n        const totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;\n        let years = Math.floor(totalMonths / MONTHS_IN_YEAR);\n        let months = totalMonths % MONTHS_IN_YEAR;\n\n        let days =\n            Math.min(\n                this.day,\n                TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years)),\n            ) + day;\n\n        while (days > TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) {\n            days -= TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));\n\n            if (months === TuiMonthNumber.December) {\n                years++;\n                months = TuiMonthNumber.January;\n            } else {\n                months++;\n            }\n        }\n\n        while (days < MIN_DAY) {\n            if (months === TuiMonthNumber.January) {\n                years--;\n                months = TuiMonthNumber.December;\n            } else {\n                months--;\n            }\n\n            days += TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));\n        }\n\n        return new TuiDay(years, months, days);\n    }\n\n    toString(): string {\n        return this.formattedDay;\n    }\n\n    toJSON(): string {\n        return `${super.toJSON()}-${this.formattedDayPart}`;\n    }\n\n    /**\n     * Returns native {@link Date} based on local time zone\n     */\n    toLocalNativeDate(): Date {\n        return new Date(this.year, this.month, this.day);\n    }\n\n    /**\n     * Returns native {@link Date} based on UTC\n     */\n    toUtcNativeDate(): Date {\n        return new Date(Date.UTC(this.year, this.month, this.day));\n    }\n\n    /**\n     * Creates {@link TuiDay} from native {@link Date} based on local time zone\n     */\n    static fromLocalNativeDate(date: Date): TuiDay {\n        return new TuiDay(date.getFullYear(), date.getMonth(), date.getDate());\n    }\n\n    /**\n     * Creates {@link TuiDay} from native {@link Date} using UTC\n     */\n    static fromUtcNativeDate(date: Date): TuiDay {\n        return new TuiDay(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());\n    }\n\n    /**\n     * Check validity of year, month and day\n     *\n     * @param year\n     * @param month\n     * @param day\n     * @return boolean validity\n     */\n    static isValidDay(year: number, month: number, day: number): boolean {\n        return (\n            TuiMonth.isValidMonth(year, month) &&\n            Number.isInteger(day) &&\n            inRange(\n                day,\n                MIN_DAY,\n                TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1,\n            )\n        );\n    }\n\n    /**\n     * Calculated day on a calendar grid\n     *\n     * @param month\n     * @param row row in a calendar\n     * @param col column in a calendar\n     * @return resulting day on these coordinates (could exceed passed month)\n     */\n    static getDayFromMonthRowCol(month: TuiMonth, row: number, col: number): TuiDay {\n        tuiAssert.assert(Number.isInteger(row));\n        tuiAssert.assert(inRange(row, 0, 6));\n        tuiAssert.assert(Number.isInteger(col));\n        tuiAssert.assert(inRange(col, 0, DAYS_IN_WEEK));\n\n        let day = row * DAYS_IN_WEEK + col - month.monthStartDaysOffset + 1;\n\n        if (day > month.daysCount) {\n            day = day - month.daysCount;\n            month = month.append({month: 1});\n        }\n\n        if (day <= 0) {\n            month = month.append({month: -1});\n            day = month.daysCount + day;\n        }\n\n        return new TuiDay(month.year, month.month, day);\n    }\n\n    /**\n     * Current day based on local time zone\n     */\n    static currentLocal(): TuiDay {\n        const nativeDate = new Date();\n        const year = nativeDate.getFullYear();\n        const month = nativeDate.getMonth();\n        const day = nativeDate.getDate();\n\n        return new TuiDay(year, month, day);\n    }\n\n    /**\n     * Calculates {@link TuiDay} normalizing year, month and day. {@link NaN} is turned into minimal value.\n     *\n     * @param year any year value, including invalid\n     * @param month any month value, including invalid (months start with 0)\n     * @param day any day value, including invalid\n     * @return normalized date\n     */\n    static normalizeOf(year: number, month: number, day: number): TuiDay {\n        const normalizedYear = TuiYear.normalizeYearPart(year);\n        const normalizedMonth = TuiMonth.normalizeMonthPart(month);\n        const normalizedDay = TuiDay.normalizeDayPart(\n            day,\n            normalizedMonth,\n            normalizedYear,\n        );\n\n        return new TuiDay(normalizedYear, normalizedMonth, normalizedDay);\n    }\n\n    static lengthBetween(from: TuiDay, to: TuiDay): number {\n        return Math.round(\n            (to.toLocalNativeDate().getTime() - from.toLocalNativeDate().getTime()) /\n                (1000 * 60 * 60 * 24),\n        );\n    }\n\n    // TODO: Move month and year related code corresponding classes\n    /**\n     * Parsing a string with date with normalization\n     *\n     * @param yearMonthDayString date string in format of DD.MM.Yyyy\n     * @return normalized date\n     */\n    static normalizeParse(yearMonthDayString: string): TuiDay {\n        const day = parseInt(yearMonthDayString.slice(0, 2), 10);\n        const month = parseInt(yearMonthDayString.slice(3, 5), 10) - 1;\n        const year = parseInt(yearMonthDayString.slice(6, 10), 10);\n\n        return TuiDay.normalizeOf(year, month, day);\n    }\n\n    /**\n     * Parsing a date stringified in a toJSON format\n     * @param yearMonthDayString date string in format of YYYY-MM-DD\n     * @return date\n     * @throws exceptions if any part of the date is invalid\n     */\n    static jsonParse(yearMonthDayString: string): TuiDay {\n        const day = parseInt(yearMonthDayString.slice(8, 10), 10);\n        const month = parseInt(yearMonthDayString.slice(5, 7), 10) - 1;\n        const year = parseInt(yearMonthDayString.slice(0, 4), 10);\n\n        if (!TuiYear.isValidYear(year)) {\n            throw new Error('Invalid year: ' + year);\n        }\n\n        if (!TuiMonth.isValidMonth(year, month)) {\n            throw new Error('Invalid month: ' + month);\n        }\n\n        if (\n            !Number.isInteger(day) ||\n            !inRange(\n                day,\n                MIN_DAY,\n                TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1,\n            )\n        ) {\n            throw new Error('Invalid day: ' + day);\n        }\n\n        return new TuiDay(year, month, day);\n    }\n\n    protected static normalizeDayPart(day: number, month: number, year: number): number {\n        tuiAssert.assert(TuiMonth.isValidMonth(year, month));\n\n        const monthDaysCount = TuiMonth.getMonthDaysCount(\n            month,\n            TuiYear.isLeapYear(year),\n        );\n\n        return normalizeToIntNumber(day, 1, monthDaysCount);\n    }\n}\n","import {MAX_MONTH, MAX_YEAR, MIN_DAY, MIN_MONTH, MIN_YEAR} from './date-time';\nimport {TuiDay} from './day';\n\nexport const TUI_FIRST_DAY = new TuiDay(MIN_YEAR, MIN_MONTH, MIN_DAY);\n\nexport const TUI_LAST_DAY = new TuiDay(MAX_YEAR, MAX_MONTH, 31);\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\nimport {RANGE_SEPARATOR_CHAR} from './date-time';\nimport {TuiMonth} from './month';\n\n/**\n * An immutable range of two {@link TuiMonth} objects\n */\nexport class TuiMonthRange {\n    constructor(readonly from: TuiMonth, readonly to: TuiMonth) {\n        tuiAssert.assert(from.monthSameOrBefore(to));\n    }\n\n    get isSingleMonth(): boolean {\n        return this.from.monthSame(this.to);\n    }\n\n    get formattedMonthRange(): string {\n        return `${this.from.formattedMonth}${RANGE_SEPARATOR_CHAR}${this.to.formattedMonth}`;\n    }\n\n    monthSame(another: TuiMonthRange): boolean {\n        return this.from.monthSame(another.from) && this.to.monthSame(another.to);\n    }\n\n    toString(): string {\n        return `${this.from}${RANGE_SEPARATOR_CHAR}${this.to}`;\n    }\n\n    static sort(month1: TuiMonth, month2: TuiMonth): TuiMonthRange {\n        return month1.monthSameOrBefore(month2)\n            ? new TuiMonthRange(month1, month2)\n            : new TuiMonthRange(month2, month1);\n    }\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\nimport {RANGE_SEPARATOR_CHAR} from './date-time';\nimport {TuiDay} from './day';\nimport {TuiMonthRange} from './month-range';\n\n/**\n * An immutable range of two {@link TuiDay} objects\n */\nexport class TuiDayRange extends TuiMonthRange {\n    constructor(readonly from: TuiDay, readonly to: TuiDay) {\n        super(from, to);\n\n        tuiAssert.assert(from.daySameOrBefore(to));\n    }\n\n    get isSingleDay(): boolean {\n        return this.from.daySame(this.to);\n    }\n\n    /**\n     * Human readable format.\n     */\n    get formattedDayRange(): string {\n        return `${this.from.formattedDay}${RANGE_SEPARATOR_CHAR}${this.to.formattedDay}`;\n    }\n\n    /**\n     * Tests ranges for identity\n     *\n     * @param another second range to test against current\n     * @return `true` if days are identical\n     */\n    daySame(another: TuiDayRange): boolean {\n        return this.from.daySame(another.from) && this.to.daySame(another.to);\n    }\n\n    /**\n     * Locks range between two days included, or limits from one side if the other is null\n     *\n     * @param min\n     * @param max\n     * @return range  clamped range\n     */\n    dayLimit(min: TuiDay | null, max: TuiDay | null): TuiDayRange {\n        return new TuiDayRange(this.from.dayLimit(min, max), this.to.dayLimit(min, max));\n    }\n\n    /**\n     * Creates range from two days after sorting them\n     *\n     * @param day1\n     * @param day2\n     * @return new range with sorted days\n     */\n    static sort(day1: TuiDay, day2: TuiDay): TuiDayRange {\n        return day1.daySameOrBefore(day2)\n            ? new TuiDayRange(day1, day2)\n            : new TuiDayRange(day2, day1);\n    }\n\n    /**\n     * Parse and correct a day range in string format\n     *\n     * @param rangeString a string of dates in a format dd.mm.yyyy - dd.mm.yyyy\n     * @return normalized day range object\n     */\n    static normalizeParse(\n        rangeString: string,\n        dateFiller: string,\n        dateRangeFiller: string,\n    ): TuiDayRange {\n        const leftDay = TuiDay.normalizeParse(rangeString.slice(0, dateFiller.length));\n\n        if (rangeString.length < dateRangeFiller.length) {\n            return new TuiDayRange(leftDay, leftDay);\n        }\n\n        return TuiDayRange.sort(\n            leftDay,\n            TuiDay.normalizeParse(\n                rangeString.slice(dateFiller.length + RANGE_SEPARATOR_CHAR.length),\n            ),\n        );\n    }\n}\n","import {inject, InjectionToken} from '@angular/core';\nimport {RANGE_SEPARATOR_CHAR} from './date-time';\n\n// TODO: think about yyyy.mm.dd format\nexport const TUI_DATE_FILLER = new InjectionToken<string>('date filler for Taiga UI', {\n    factory: () => `dd.mm.yyyy`,\n});\n\nexport const TUI_DATE_RANGE_FILLER = new InjectionToken<string>(\n    'date range filler for Taiga UI',\n    {\n        factory: () => {\n            const dateFiller = inject(TUI_DATE_FILLER);\n\n            return `${dateFiller}${RANGE_SEPARATOR_CHAR}${dateFiller}`;\n        },\n    },\n);\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\nimport {TuiTimeLike} from '@taiga-ui/cdk/interfaces';\nimport {TuiTimeMode} from '@taiga-ui/cdk/types';\nimport {padStart} from '@taiga-ui/cdk/utils/format';\nimport {inRange} from '@taiga-ui/cdk/utils/math';\nimport {\n    HOURS_IN_DAY,\n    MILLISECONDS_IN_DAY,\n    MILLISECONDS_IN_HOUR,\n    MILLISECONDS_IN_MINUTE,\n    MINUTES_IN_HOUR,\n    SECONDS_IN_MINUTE,\n} from './date-time';\n\n/**\n * Immutable time object with hours, minutes, seconds and ms\n */\nexport class TuiTime implements TuiTimeLike {\n    constructor(\n        readonly hours: number,\n        readonly minutes: number,\n        readonly seconds: number = 0,\n        readonly ms: number = 0,\n    ) {\n        tuiAssert.assert(\n            TuiTime.isValidTime(hours, minutes, seconds, ms),\n            'Time must be real, but got:',\n            hours,\n            minutes,\n            seconds,\n            ms,\n        );\n    }\n\n    /**\n     * Shifts time by hours and minutes\n     */\n    shift({hours = 0, minutes = 0, seconds = 0, ms = 0}: TuiTimeLike): TuiTime {\n        const newMs = (1000 + this.ms + (ms % 1000)) % 1000;\n\n        const secondsInMs = ms < 0 ? Math.ceil(ms / 1000) : Math.floor(ms / 1000);\n        const secondsToAdd = secondsInMs + seconds;\n        const newSeconds = (60 + this.seconds + (secondsToAdd % 60)) % 60;\n\n        const minutesInSeconds =\n            secondsToAdd < 0\n                ? Math.ceil(secondsToAdd / 60)\n                : Math.floor(secondsToAdd / 60);\n        const minutesToAdd = minutesInSeconds + minutes;\n        const newMinutes = (60 + this.minutes + (minutesToAdd % 60)) % 60;\n\n        const hoursInMinutes =\n            minutesToAdd < 0\n                ? Math.ceil(minutesToAdd / 60)\n                : Math.floor(minutesToAdd / 60);\n        const hoursToAdd = hoursInMinutes + hours;\n        const newHours = (24 + this.hours + (hoursToAdd % 24)) % 24;\n\n        return new TuiTime(newHours, newMinutes, newSeconds, newMs);\n    }\n\n    /**\n     * Converts TuiTime to string\n     */\n    toString(mode?: TuiTimeMode): string {\n        const needAddMs = mode === 'HH:MM:SS.MSS' || (!mode && this.ms > 0);\n        const needAddSeconds =\n            needAddMs || mode === 'HH:MM:SS' || (!mode && this.seconds > 0);\n\n        return (\n            `${this.formatTime(this.hours)}:${this.formatTime(this.minutes)}` +\n            `${needAddSeconds ? ':' + this.formatTime(this.seconds) : ''}` +\n            `${needAddMs ? '.' + this.formatTime(this.ms, 3) : ''}`\n        );\n    }\n\n    /**\n     * Converts TuiTime to milliseconds\n     */\n    toAbsoluteMilliseconds(): number {\n        return (\n            this.hours * MILLISECONDS_IN_HOUR +\n            this.minutes * MILLISECONDS_IN_MINUTE +\n            this.seconds * 1000 +\n            this.ms\n        );\n    }\n\n    /**\n     * Checks if time is valid\n     */\n    static isValidTime(\n        hours: number,\n        minutes: number,\n        seconds: number = 0,\n        ms: number = 0,\n    ): boolean {\n        return (\n            Number.isInteger(hours) &&\n            inRange(hours, 0, HOURS_IN_DAY) &&\n            Number.isInteger(minutes) &&\n            inRange(minutes, 0, MINUTES_IN_HOUR) &&\n            Number.isInteger(seconds) &&\n            inRange(seconds, 0, SECONDS_IN_MINUTE) &&\n            Number.isInteger(ms) &&\n            inRange(ms, 0, 1000)\n        );\n    }\n\n    /**\n     * Current UTC time.\n     */\n    static current(): TuiTime {\n        return TuiTime.fromAbsoluteMilliseconds(Date.now() % MILLISECONDS_IN_DAY);\n    }\n\n    /**\n     * Current time in local timezone\n     */\n    static currentLocal(): TuiTime {\n        const date = new Date();\n\n        return TuiTime.fromAbsoluteMilliseconds(\n            (Date.now() - date.getTimezoneOffset() * MILLISECONDS_IN_MINUTE) %\n                MILLISECONDS_IN_DAY,\n        );\n    }\n\n    /**\n     * Calculates TuiTime from milliseconds\n     */\n    static fromAbsoluteMilliseconds(milliseconds: number): TuiTime {\n        tuiAssert.assert(Number.isInteger(milliseconds));\n        tuiAssert.assert(\n            inRange(milliseconds, 0, MILLISECONDS_IN_DAY),\n            `Milliseconds must be below ${MILLISECONDS_IN_DAY} (milliseconds in a day).`,\n        );\n\n        const hours = Math.floor(milliseconds / MILLISECONDS_IN_HOUR);\n        const minutes = Math.floor(\n            (milliseconds % MILLISECONDS_IN_HOUR) / MILLISECONDS_IN_MINUTE,\n        );\n        const seconds =\n            Math.floor(\n                ((milliseconds % MILLISECONDS_IN_HOUR) % MILLISECONDS_IN_MINUTE) / 1000,\n            ) || 0;\n        const ms =\n            Math.floor(\n                ((milliseconds % MILLISECONDS_IN_HOUR) % MILLISECONDS_IN_MINUTE) % 1000,\n            ) || 0;\n\n        return new TuiTime(hours, minutes, seconds, ms);\n    }\n\n    /**\n     * Parses string into TuiTime object\n     */\n    static fromString(time: string): TuiTime {\n        const hours = Number(time.slice(0, 2));\n        const minutes = Number(time.slice(3, 5));\n        const seconds = Number(time.slice(6, 8)) || 0;\n        const ms = Number(time.slice(9, 12)) || 0;\n\n        return new TuiTime(hours, minutes, seconds, ms);\n    }\n\n    private formatTime(time: number, digits: number = 2): string {\n        return padStart(time.toString(), digits, '0');\n    }\n}\n"]}