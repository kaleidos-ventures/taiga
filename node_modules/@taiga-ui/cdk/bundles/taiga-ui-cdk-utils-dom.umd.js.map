{"version":3,"file":"taiga-ui-cdk-utils-dom.umd.js","sources":["ng://@taiga-ui/cdk/utils/dom/can-scroll.ts","ng://@taiga-ui/cdk/utils/dom/contains-or-after.ts","ng://@taiga-ui/cdk/utils/dom/custom-event.ts","ng://@taiga-ui/cdk/utils/dom/get-actual-target.ts","ng://@taiga-ui/cdk/utils/dom/get-clipboard-data-text.ts","ng://@taiga-ui/cdk/utils/dom/get-closest-element.ts","ng://@taiga-ui/cdk/utils/dom/get-document-or-shadow-root.ts","ng://@taiga-ui/cdk/utils/dom/get-element-obscurers.ts","ng://@taiga-ui/cdk/utils/dom/get-element-offset.ts","ng://@taiga-ui/cdk/utils/dom/get-scroll-parent.ts","ng://@taiga-ui/cdk/utils/dom/is-current-target.ts","ng://@taiga-ui/cdk/utils/dom/is-node-in.ts"],"sourcesContent":["export function canScroll(\n    element: Element,\n    rootElement: Element,\n    vertical: boolean,\n    scrollEnd: boolean,\n): boolean {\n    return vertical\n        ? canScrollVertical(element, rootElement, scrollEnd)\n        : canScrollHorizontal(element, rootElement, scrollEnd);\n}\n\nfunction canScrollVertical(\n    element: Element,\n    rootElement: Element,\n    scrollEnd: boolean,\n): boolean {\n    let currentElement = element;\n\n    while (currentElement !== rootElement.parentElement) {\n        if (\n            (Math.floor(currentElement.scrollTop) > 0 && !scrollEnd) ||\n            (Math.ceil(currentElement.scrollTop + currentElement.clientHeight) <\n                currentElement.scrollHeight &&\n                scrollEnd)\n        ) {\n            return true;\n        }\n\n        if (currentElement.parentElement) {\n            currentElement = currentElement.parentElement;\n        } else {\n            return false;\n        }\n    }\n\n    return false;\n}\n\nfunction canScrollHorizontal(\n    element: Element,\n    rootElement: Element,\n    scrollEnd: boolean,\n): boolean {\n    let currentElement = element;\n\n    while (currentElement !== rootElement.parentElement) {\n        if (\n            (Math.floor(currentElement.scrollLeft) > 0 && !scrollEnd) ||\n            (Math.ceil(currentElement.scrollLeft + currentElement.clientWidth) <\n                currentElement.scrollWidth &&\n                scrollEnd)\n        ) {\n            return true;\n        }\n\n        if (currentElement.parentElement) {\n            currentElement = currentElement.parentElement;\n        } else {\n            return false;\n        }\n    }\n\n    return false;\n}\n","export function containsOrAfter(current: Node, node: Node): boolean {\n    return (\n        current.contains(node) ||\n        !!(\n            // tslint:disable:no-bitwise\n            (node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING)\n        )\n    );\n}\n","export function tuiCustomEvent<T = null>(\n    name: string,\n    {bubbles = false, cancelable = false, detail = null}: CustomEventInit<T | null> = {},\n    documentRef: Document,\n): CustomEvent {\n    if (typeof CustomEvent === 'function') {\n        return new CustomEvent(name, {bubbles, cancelable, detail});\n    }\n\n    const customEvent = documentRef.createEvent('CustomEvent');\n\n    customEvent.initCustomEvent(name, bubbles, cancelable, detail);\n\n    return customEvent;\n}\n","/**\n * Gets actual target from open Shadow DOM if event happened within it\n */\nexport function getActualTarget(event: Event): Node {\n    if ('composedPath' in event) {\n        return (event as any).composedPath()[0];\n    }\n\n    return (event as any).target;\n}\n","/**\n * Gets text from data of clipboardEvent, it also works in IE and Edge browsers\n */\nexport function getClipboardDataText(\n    event: ClipboardEvent,\n    format: string = 'text/plain',\n): string {\n    return 'clipboardData' in event && event.clipboardData !== null\n        ? event.clipboardData.getData(format)\n        : (event as any).target.ownerDocument.defaultView.clipboardData.getData('text');\n}\n","/**\n * Gets closest element by selector i.e. {@link Element.closest}\n */\nexport function getClosestElement(element: Element, selector: string): Element | null {\n    const closest = Element.prototype.closest;\n\n    if (closest) {\n        return closest.call(element, selector);\n    }\n\n    const matchesSelector =\n        Element.prototype.matches || (Element.prototype as any).msMatchesSelector;\n\n    do {\n        if (matchesSelector.call(element, selector)) {\n            return element;\n        }\n\n        (element as Element | null) = element.parentElement;\n    } while (element !== null);\n\n    return null;\n}\n","export function getDocumentOrShadowRoot(node: Node): DocumentOrShadowRoot {\n    return 'getRootNode' in node &&\n        node.ownerDocument &&\n        node.ownerDocument.body.contains(node)\n        ? (node.getRootNode() as Document)\n        : node.ownerDocument!;\n}\n","import {clamp} from '@taiga-ui/cdk/utils/math';\nimport {isPresent} from '@taiga-ui/cdk/utils/miscellaneous';\nimport {getDocumentOrShadowRoot} from './get-document-or-shadow-root';\n\n/**\n * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible\n *\n * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered\n */\nexport function getElementObscurers(element: Element): ReadonlyArray<Element> | null {\n    const {ownerDocument} = element;\n\n    if (!ownerDocument || !ownerDocument.defaultView) {\n        return null;\n    }\n\n    const {innerWidth, innerHeight} = ownerDocument.defaultView;\n    const documentRef = getDocumentOrShadowRoot(element);\n    const rect = element.getBoundingClientRect();\n    const left = clamp(Math.round(rect.left) + 2, 0, innerWidth);\n    const top = clamp(Math.round(rect.top) + 2, 0, innerHeight);\n    const right = clamp(Math.round(rect.right) - 2, 0, innerWidth);\n    const bottom = clamp(Math.round(rect.bottom) - 2, 0, innerHeight);\n    const horizontalMiddle = clamp(Math.round(rect.left + rect.width / 2), 0, innerWidth);\n    const verticalMiddle = clamp(Math.round(rect.top + rect.height / 2), 0, innerHeight);\n    const elements = [\n        documentRef.elementFromPoint(horizontalMiddle, top),\n        documentRef.elementFromPoint(horizontalMiddle, bottom),\n        documentRef.elementFromPoint(left, verticalMiddle),\n        documentRef.elementFromPoint(right, verticalMiddle),\n    ];\n    const nonNull = elements.filter(isPresent);\n\n    if (!nonNull.length) {\n        return nonNull;\n    }\n\n    const filtered = nonNull.filter(el => !element.contains(el));\n\n    return filtered.length === 4 ? filtered : null;\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\n\n/**\n * Calculates offset for an element relative to it's parent several levels above\n *\n * @param host parent element\n * @param element\n * @return object with offsetTop and offsetLeft number properties\n */\nexport function getElementOffset(\n    host: Element,\n    element: HTMLElement,\n): {offsetTop: number; offsetLeft: number} {\n    tuiAssert.assert(host.contains(element), 'Host must contain element');\n\n    let {offsetTop, offsetLeft, offsetParent} = element;\n\n    while (offsetParent && offsetParent instanceof HTMLElement && offsetParent !== host) {\n        offsetTop += offsetParent.offsetTop;\n        offsetLeft += offsetParent.offsetLeft;\n        offsetParent = offsetParent.offsetParent;\n    }\n\n    return {offsetTop, offsetLeft};\n}\n","/**\n * Finds nearest parent with scroll in it\n *\n * @param element initial element\n * @param vertical flag for orientation of scroll\n */\nexport function getScrollParent(\n    element: Element | null,\n    vertical: boolean = true,\n): Element | null {\n    if (element === null) {\n        return null;\n    }\n\n    if (vertical && element.scrollHeight > element.clientHeight) {\n        return element;\n    }\n\n    if (!vertical && element.scrollWidth > element.clientWidth) {\n        return element;\n    }\n\n    return getScrollParent(element.parentElement, vertical);\n}\n","export function isCurrentTarget({target, currentTarget}: Event): boolean {\n    return target === currentTarget;\n}\n","import {getClosestElement} from './get-closest-element';\n\n/**\n * Checks if node is inside a specific selector\n *\n * @param node\n * @param selector\n * @return true if node is inside a particular selector\n */\nexport function isNodeIn(node: Node, selector: string): boolean {\n    return node.nodeType === Node.TEXT_NODE\n        ? !!node.parentElement && !!getClosestElement(node.parentElement, selector)\n        : node.nodeType === Node.ELEMENT_NODE &&\n              !!getClosestElement(node as Element, selector);\n}\n"],"names":["clamp","isPresent","tuiAssert"],"mappings":"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"}