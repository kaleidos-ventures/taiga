import { __decorate, __param } from "tslib";
import { Directive, ElementRef, EventEmitter, HostListener, Inject, Input, Output, Renderer2, } from '@angular/core';
var TuiCheckedDirective = /** @class */ (function () {
    function TuiCheckedDirective(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.tuiCheckedChange = new EventEmitter();
        this.updateProperty('checked', false);
    }
    Object.defineProperty(TuiCheckedDirective.prototype, "tuiChecked", {
        set: function (checked) {
            this.updateProperty('checked', checked || false);
            this.updateProperty('indeterminate', checked === null);
        },
        enumerable: true,
        configurable: true
    });
    TuiCheckedDirective.prototype.onChange = function (_a) {
        var checked = _a.checked;
        this.updateProperty('indeterminate', false);
        this.tuiCheckedChange.emit(checked);
    };
    TuiCheckedDirective.prototype.updateProperty = function (property, value) {
        this.renderer.setProperty(this.element.nativeElement, property, value);
    };
    TuiCheckedDirective.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Renderer2, decorators: [{ type: Inject, args: [Renderer2,] }] }
    ]; };
    __decorate([
        Input()
    ], TuiCheckedDirective.prototype, "tuiChecked", null);
    __decorate([
        Output()
    ], TuiCheckedDirective.prototype, "tuiCheckedChange", void 0);
    __decorate([
        HostListener('change', ['$event.target'])
    ], TuiCheckedDirective.prototype, "onChange", null);
    TuiCheckedDirective = __decorate([
        Directive({
            selector: 'input[tuiChecked], input[tuiCheckedChange]',
        }),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(Renderer2))
    ], TuiCheckedDirective);
    return TuiCheckedDirective;
}());
export { TuiCheckedDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tlZC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdGFpZ2EtdWkvY2RrL2RpcmVjdGl2ZXMvY2hlY2tlZC8iLCJzb3VyY2VzIjpbImNoZWNrZWQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0gsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osWUFBWSxFQUNaLE1BQU0sRUFDTixLQUFLLEVBQ0wsTUFBTSxFQUNOLFNBQVMsR0FDWixNQUFNLGVBQWUsQ0FBQztBQUt2QjtJQVVJLDZCQUVxQixPQUFxQyxFQUNsQixRQUFtQjtRQUR0QyxZQUFPLEdBQVAsT0FBTyxDQUE4QjtRQUNsQixhQUFRLEdBQVIsUUFBUSxDQUFXO1FBTGxELHFCQUFnQixHQUFHLElBQUksWUFBWSxFQUFXLENBQUM7UUFPcEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQWRELHNCQUFJLDJDQUFVO2FBQWQsVUFBZSxPQUF1QjtZQUNsQyxJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsRUFBRSxPQUFPLElBQUksS0FBSyxDQUFDLENBQUM7WUFDakQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLEVBQUUsT0FBTyxLQUFLLElBQUksQ0FBQyxDQUFDO1FBQzNELENBQUM7OztPQUFBO0lBY0Qsc0NBQVEsR0FBUixVQUFTLEVBQTJCO1lBQTFCLG9CQUFPO1FBQ2IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDNUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRU8sNENBQWMsR0FBdEIsVUFBdUIsUUFBcUMsRUFBRSxLQUFjO1FBQ3hFLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUMzRSxDQUFDOztnQkFkNkIsVUFBVSx1QkFEbkMsTUFBTSxTQUFDLFVBQVU7Z0JBRTRCLFNBQVMsdUJBQXRELE1BQU0sU0FBQyxTQUFTOztJQVhyQjtRQURDLEtBQUssRUFBRTt5REFJUDtJQUdEO1FBREMsTUFBTSxFQUFFO2lFQUMrQztJQVd4RDtRQURDLFlBQVksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxlQUFlLENBQUMsQ0FBQzt1REFJekM7SUF0QlEsbUJBQW1CO1FBSC9CLFNBQVMsQ0FBQztZQUNQLFFBQVEsRUFBRSw0Q0FBNEM7U0FDekQsQ0FBQztRQVlPLFdBQUEsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFBO1FBRWxCLFdBQUEsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFBO09BYmIsbUJBQW1CLENBMkIvQjtJQUFELDBCQUFDO0NBQUEsQUEzQkQsSUEyQkM7U0EzQlksbUJBQW1CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdExpc3RlbmVyLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsXG4gICAgUmVuZGVyZXIyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdpbnB1dFt0dWlDaGVja2VkXSwgaW5wdXRbdHVpQ2hlY2tlZENoYW5nZV0nLFxufSlcbmV4cG9ydCBjbGFzcyBUdWlDaGVja2VkRGlyZWN0aXZlIHtcbiAgICBASW5wdXQoKVxuICAgIHNldCB0dWlDaGVja2VkKGNoZWNrZWQ6IG51bGwgfCBib29sZWFuKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUHJvcGVydHkoJ2NoZWNrZWQnLCBjaGVja2VkIHx8IGZhbHNlKTtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9wZXJ0eSgnaW5kZXRlcm1pbmF0ZScsIGNoZWNrZWQgPT09IG51bGwpO1xuICAgIH1cblxuICAgIEBPdXRwdXQoKVxuICAgIHJlYWRvbmx5IHR1aUNoZWNrZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChFbGVtZW50UmVmKVxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTElucHV0RWxlbWVudD4sXG4gICAgICAgIEBJbmplY3QoUmVuZGVyZXIyKSBwcml2YXRlIHJlYWRvbmx5IHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUHJvcGVydHkoJ2NoZWNrZWQnLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignY2hhbmdlJywgWyckZXZlbnQudGFyZ2V0J10pXG4gICAgb25DaGFuZ2Uoe2NoZWNrZWR9OiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlUHJvcGVydHkoJ2luZGV0ZXJtaW5hdGUnLCBmYWxzZSk7XG4gICAgICAgIHRoaXMudHVpQ2hlY2tlZENoYW5nZS5lbWl0KGNoZWNrZWQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlUHJvcGVydHkocHJvcGVydHk6ICdjaGVja2VkJyB8ICdpbmRldGVybWluYXRlJywgdmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICB9XG59XG4iXX0=