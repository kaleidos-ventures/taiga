import { __decorate, __param } from 'tslib';
import { DOCUMENT } from '@angular/common';
import { Inject, ElementRef, Renderer2, HostListener, Directive, NgModule } from '@angular/core';
import { containsOrAfter } from '@taiga-ui/cdk/utils/dom';
import { getNativeFocused, setNativeFocused, getClosestKeyboardFocusable, blurNativeFocused } from '@taiga-ui/cdk/utils/focus';

// @dynamic
let TuiFocusTrapDirective = class TuiFocusTrapDirective {
    constructor(documentRef, elementRef, renderer) {
        this.documentRef = documentRef;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.activeElement = getNativeFocused(this.documentRef);
        /**
         * This would cause currently focused element to lose focus
         * but it might cause ExpressionChanged error due to potential HostBinding.
         * Microtask keeps it in the same frame but allows change detection to run
         */
        Promise.resolve().then(() => {
            setNativeFocused(this.elementRef.nativeElement);
        });
    }
    onBlur() {
        this.renderer.removeAttribute(this.elementRef.nativeElement, 'tabIndex');
    }
    onFocusIn(node) {
        if (containsOrAfter(this.elementRef.nativeElement, node)) {
            return;
        }
        const focusable = getClosestKeyboardFocusable(this.elementRef.nativeElement, false, this.elementRef.nativeElement);
        if (focusable) {
            setNativeFocused(focusable);
        }
    }
    ngOnDestroy() {
        blurNativeFocused(this.documentRef);
        /**
         * HostListeners are triggered even after ngOnDestroy
         * {@link https://github.com/angular/angular/issues/38100}
         * so we need to delay it but stay in the same sync cycle,
         * therefore using Promise instead of setTimeout
         */
        Promise.resolve().then(() => {
            if (this.activeElement instanceof HTMLElement) {
                setNativeFocused(this.activeElement);
            }
        });
    }
};
TuiFocusTrapDirective.ctorParameters = () => [
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Renderer2, decorators: [{ type: Inject, args: [Renderer2,] }] }
];
__decorate([
    HostListener('blur')
], TuiFocusTrapDirective.prototype, "onBlur", null);
__decorate([
    HostListener('window:focusin.silent', ['$event.target'])
], TuiFocusTrapDirective.prototype, "onFocusIn", null);
TuiFocusTrapDirective = __decorate([
    Directive({
        selector: '[tuiFocusTrap]',
        host: {
            tabIndex: '0',
        },
    }),
    __param(0, Inject(DOCUMENT)),
    __param(1, Inject(ElementRef)),
    __param(2, Inject(Renderer2))
], TuiFocusTrapDirective);

let TuiFocusTrapModule = class TuiFocusTrapModule {
};
TuiFocusTrapModule = __decorate([
    NgModule({
        declarations: [TuiFocusTrapDirective],
        exports: [TuiFocusTrapDirective],
    })
], TuiFocusTrapModule);

/**
 * Generated bundle index. Do not edit.
 */

export { TuiFocusTrapDirective, TuiFocusTrapModule };
//# sourceMappingURL=taiga-ui-cdk-directives-focus-trap.js.map
