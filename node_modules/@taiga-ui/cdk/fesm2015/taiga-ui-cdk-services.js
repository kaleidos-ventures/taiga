import { __decorate, __param } from 'tslib';
import { Injectable, Inject, Renderer2, ɵɵdefineInjectable, ɵɵinject, ElementRef, ChangeDetectorRef, NgZone, Self } from '@angular/core';
import { Subject, Observable, merge, defer, fromEvent, interval, of, timer } from 'rxjs';
import { DOCUMENT } from '@angular/common';
import { TUI_DEFAULT_RENDERER } from '@taiga-ui/cdk/tokens';
import { focusVisibleObservable, watch, typedFromEvent, tuiZoneOptimized, tuiZonefree } from '@taiga-ui/cdk/observables';
import { takeUntil, switchMap, filter, take, mapTo, startWith, distinctUntilChanged, delay, map, catchError, debounceTime, tap, shareReplay } from 'rxjs/operators';
import { getActualTarget, getElementObscurers } from '@taiga-ui/cdk/utils/dom';
import { WINDOW, PERFORMANCE, ANIMATION_FRAME } from '@ng-web-apis/common';
import { POLLING_TIME, EMPTY_ARRAY } from '@taiga-ui/cdk/constants';
import { ResizeObserverService, RESIZE_OBSERVER_SUPPORT, RESIZE_OPTION_BOX } from '@ng-web-apis/resize-observer';
import { tuiAssert } from '@taiga-ui/cdk/classes';
import { clamp } from '@taiga-ui/cdk/utils/math';
import { easeInOutQuad } from '@taiga-ui/cdk/utils/miscellaneous';

/**
 * Observable abstraction over ngOnDestroy to use with takeUntil
 */
let TuiDestroyService = class TuiDestroyService extends Subject {
    ngOnDestroy() {
        this.next();
        this.complete();
    }
};
TuiDestroyService = __decorate([
    Injectable()
], TuiDestroyService);

/**
 * Service to use styles with directives
 * @dynamic
 */
let TuiDirectiveStylesService = class TuiDirectiveStylesService {
    constructor(documentRef, renderer) {
        this.documentRef = documentRef;
        this.renderer = renderer;
    }
    addStyle(styles, attribute) {
        if (this.documentRef.head.querySelector(`style[${attribute}]`)) {
            return;
        }
        const style = this.renderer.createElement('style');
        this.renderer.setProperty(style, 'textContent', styles);
        this.renderer.setAttribute(style, attribute, '');
        this.documentRef.head.appendChild(style);
    }
};
TuiDirectiveStylesService.ctorParameters = () => [
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Renderer2, decorators: [{ type: Inject, args: [TUI_DEFAULT_RENDERER,] }] }
];
TuiDirectiveStylesService.ɵprov = ɵɵdefineInjectable({ factory: function TuiDirectiveStylesService_Factory() { return new TuiDirectiveStylesService(ɵɵinject(DOCUMENT), ɵɵinject(TUI_DEFAULT_RENDERER)); }, token: TuiDirectiveStylesService, providedIn: "root" });
TuiDirectiveStylesService = __decorate([
    Injectable({
        providedIn: 'root',
    }),
    __param(0, Inject(DOCUMENT)),
    __param(1, Inject(TUI_DEFAULT_RENDERER))
], TuiDirectiveStylesService);

/**
 * Service to imitate :focus-visible
 * (https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible)
 * in browsers that do not support it
 * @dynamic
 */
let TuiFocusVisibleService = class TuiFocusVisibleService extends Observable {
    constructor({ nativeElement }, changeDetectorRef, destroy$) {
        super(subscriber => this.focusVisible$.subscribe(subscriber));
        this.focusVisible$ = focusVisibleObservable(nativeElement).pipe(watch(changeDetectorRef), takeUntil(destroy$));
    }
};
TuiFocusVisibleService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] }
];
TuiFocusVisibleService = __decorate([
    Injectable(),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(ChangeDetectorRef)),
    __param(2, Inject(TuiDestroyService))
], TuiFocusVisibleService);

// @dynamic
let TuiHoveredService = class TuiHoveredService {
    constructor(documentRef, ngZone) {
        this.ngZone = ngZone;
        this.documentEvents$ = merge(typedFromEvent(documentRef, 'mousemove'), typedFromEvent(documentRef, 'touchend'));
    }
    createHovered$(target, options = {}) {
        return merge(typedFromEvent(target, 'mouseenter', options), typedFromEvent(target, 'touchstart', options)).pipe(switchMap(() => merge(typedFromEvent(target, 'mouseleave', options), this.documentEvents$.pipe(filter(event => !target.contains(getActualTarget(event))), tuiZoneOptimized(this.ngZone), take(1))).pipe(mapTo(false), startWith(true))), distinctUntilChanged());
    }
};
TuiHoveredService.ctorParameters = () => [
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] }
];
TuiHoveredService.ɵprov = ɵɵdefineInjectable({ factory: function TuiHoveredService_Factory() { return new TuiHoveredService(ɵɵinject(DOCUMENT), ɵɵinject(NgZone)); }, token: TuiHoveredService, providedIn: "root" });
TuiHoveredService = __decorate([
    Injectable({
        providedIn: 'root',
    }),
    __param(0, Inject(DOCUMENT)),
    __param(1, Inject(NgZone))
], TuiHoveredService);

var TuiIdService_1;
const TUI = 'tui_';
/**
 * Generates unique ids
 */
let TuiIdService = TuiIdService_1 = class TuiIdService {
    generate() {
        return `${TUI}${TuiIdService_1.autoId++}${Date.now()}`;
    }
};
TuiIdService.autoId = 0;
TuiIdService.ɵprov = ɵɵdefineInjectable({ factory: function TuiIdService_Factory() { return new TuiIdService(); }, token: TuiIdService, providedIn: "root" });
TuiIdService = TuiIdService_1 = __decorate([
    Injectable({
        providedIn: 'root',
    })
], TuiIdService);

/**
 * Service that subscribes to scroll events of all parent elements
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiParentsScrollService = class TuiParentsScrollService extends Observable {
    constructor({ nativeElement }, windowRef) {
        super(subscriber => this.callback$.subscribe(subscriber));
        this.callback$ = defer(() => {
            const eventTargets = [windowRef, nativeElement];
            while (nativeElement.parentElement) {
                nativeElement = nativeElement.parentElement;
                eventTargets.push(nativeElement);
            }
            return merge(...eventTargets.map(element => typedFromEvent(element, 'scroll')));
        });
    }
};
TuiParentsScrollService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
];
TuiParentsScrollService = __decorate([
    Injectable(),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(WINDOW))
], TuiParentsScrollService);

// @bad TODO: Consider Intersection Observer with fallback to current implementation
/**
 * Service that monitors element visibility by subscribing to scrolls
 * and polling with set interval, returns either null or an array
 * of elements that overlap given element edges
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiObscuredService = class TuiObscuredService extends Observable {
    constructor(parentsScroll$, { nativeElement }, ngZone, windowRef, destroy$) {
        super(subscriber => this.obscured$.subscribe(subscriber));
        this.obscured$ = merge(
        // delay is added so it will not interfere with other listeners
        merge(parentsScroll$, fromEvent(windowRef, 'resize')).pipe(delay(0)), interval(POLLING_TIME)).pipe(map(() => getElementObscurers(nativeElement)), startWith(null), distinctUntilChanged(), tuiZoneOptimized(ngZone), takeUntil(destroy$));
    }
};
TuiObscuredService.ctorParameters = () => [
    { type: TuiParentsScrollService, decorators: [{ type: Inject, args: [TuiParentsScrollService,] }, { type: Self }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] }
];
TuiObscuredService = __decorate([
    Injectable(),
    __param(0, Inject(TuiParentsScrollService)),
    __param(0, Self()),
    __param(1, Inject(ElementRef)),
    __param(2, Inject(NgZone)),
    __param(3, Inject(WINDOW)),
    __param(4, Inject(TuiDestroyService))
], TuiObscuredService);

// @dynamic
let TuiResizeService = class TuiResizeService extends ResizeObserverService {
    constructor(elementRef, ngZone, destroy$, support, box) {
        super(elementRef, ngZone, support, box);
        return this.pipe(catchError(() => interval(POLLING_TIME).pipe(map(() => `${elementRef.nativeElement.clientWidth} ${elementRef.nativeElement.clientHeight}`), distinctUntilChanged(), mapTo(EMPTY_ARRAY))), takeUntil(destroy$), debounceTime(0), tuiZonefree(ngZone));
    }
};
TuiResizeService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [RESIZE_OBSERVER_SUPPORT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [RESIZE_OPTION_BOX,] }] }
];
TuiResizeService = __decorate([
    Injectable(),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(NgZone)),
    __param(2, Inject(TuiDestroyService)),
    __param(3, Inject(RESIZE_OBSERVER_SUPPORT)),
    __param(4, Inject(RESIZE_OPTION_BOX))
], TuiResizeService);

const SCROLL_TIME = 300;
// @dynamic
let TuiScrollService = class TuiScrollService {
    constructor(performanceRef, animationFrame$) {
        this.performanceRef = performanceRef;
        this.animationFrame$ = animationFrame$;
    }
    scroll$(element, scrollTop, scrollLeft = element.scrollLeft, duration = SCROLL_TIME) {
        tuiAssert.assert(duration >= 0, 'Duration cannot be negative');
        tuiAssert.assert(scrollTop >= 0, 'scrollTop cannot be negative');
        tuiAssert.assert(scrollLeft >= 0, 'scrollLeft cannot be negative');
        const initialTop = element.scrollTop;
        const initialLeft = element.scrollLeft;
        const deltaTop = scrollTop - initialTop;
        const deltaLeft = scrollLeft - initialLeft;
        const observable = !duration
            ? of([scrollTop, scrollLeft])
            : defer(() => of(this.performanceRef.now())).pipe(switchMap(start => this.animationFrame$.pipe(map(now => now - start))), takeUntil(timer(duration)), map(elapsed => easeInOutQuad(clamp(elapsed / duration, 0, 1))), map(percent => [
                initialTop + deltaTop * percent,
                initialLeft + deltaLeft * percent,
            ]));
        return observable.pipe(tap(([scrollTop, scrollLeft]) => {
            element.scrollTop = scrollTop;
            element.scrollLeft = scrollLeft;
        }));
    }
};
TuiScrollService.ctorParameters = () => [
    { type: Performance, decorators: [{ type: Inject, args: [PERFORMANCE,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] }
];
TuiScrollService = __decorate([
    Injectable(),
    __param(0, Inject(PERFORMANCE)),
    __param(1, Inject(ANIMATION_FRAME))
], TuiScrollService);

let TuiStaticRequestService = class TuiStaticRequestService {
    constructor() {
        this.cache = new Map();
    }
    request(url) {
        const cache = this.cache.get(url);
        if (cache) {
            return cache;
        }
        const observable = new Observable((observer) => {
            const xhr = new XMLHttpRequest();
            xhr.onreadystatechange = () => {
                if (xhr.readyState === 4) {
                    const response = xhr.responseType ? xhr.response : xhr.responseText;
                    if (xhr.status === 200) {
                        observer.next(response);
                        observer.complete();
                    }
                    else {
                        observer.error(response);
                    }
                }
            };
            xhr.open('GET', url);
            xhr.send();
            return () => {
                xhr.abort();
            };
        });
        const piped = observable.pipe(shareReplay(1));
        this.cache.set(url, piped);
        return piped;
    }
};
TuiStaticRequestService.ɵprov = ɵɵdefineInjectable({ factory: function TuiStaticRequestService_Factory() { return new TuiStaticRequestService(); }, token: TuiStaticRequestService, providedIn: "root" });
TuiStaticRequestService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], TuiStaticRequestService);

/**
 * Generated bundle index. Do not edit.
 */

export { TuiDestroyService, TuiDirectiveStylesService, TuiFocusVisibleService, TuiHoveredService, TuiIdService, TuiObscuredService, TuiParentsScrollService, TuiResizeService, TuiScrollService, TuiStaticRequestService };
//# sourceMappingURL=taiga-ui-cdk-services.js.map
