{"version":3,"file":"taiga-ui-cdk-utils-dom.js","sources":["ng://@taiga-ui/cdk/utils/dom/can-scroll.ts","ng://@taiga-ui/cdk/utils/dom/contains-or-after.ts","ng://@taiga-ui/cdk/utils/dom/custom-event.ts","ng://@taiga-ui/cdk/utils/dom/get-actual-target.ts","ng://@taiga-ui/cdk/utils/dom/get-clipboard-data-text.ts","ng://@taiga-ui/cdk/utils/dom/get-closest-element.ts","ng://@taiga-ui/cdk/utils/dom/get-document-or-shadow-root.ts","ng://@taiga-ui/cdk/utils/dom/get-element-obscurers.ts","ng://@taiga-ui/cdk/utils/dom/get-element-offset.ts","ng://@taiga-ui/cdk/utils/dom/get-scroll-parent.ts","ng://@taiga-ui/cdk/utils/dom/is-current-target.ts","ng://@taiga-ui/cdk/utils/dom/is-node-in.ts","ng://@taiga-ui/cdk/utils/dom/taiga-ui-cdk-utils-dom.ts"],"sourcesContent":["export function canScroll(\n    element: Element,\n    rootElement: Element,\n    vertical: boolean,\n    scrollEnd: boolean,\n): boolean {\n    return vertical\n        ? canScrollVertical(element, rootElement, scrollEnd)\n        : canScrollHorizontal(element, rootElement, scrollEnd);\n}\n\nfunction canScrollVertical(\n    element: Element,\n    rootElement: Element,\n    scrollEnd: boolean,\n): boolean {\n    let currentElement = element;\n\n    while (currentElement !== rootElement.parentElement) {\n        if (\n            (Math.floor(currentElement.scrollTop) > 0 && !scrollEnd) ||\n            (Math.ceil(currentElement.scrollTop + currentElement.clientHeight) <\n                currentElement.scrollHeight &&\n                scrollEnd)\n        ) {\n            return true;\n        }\n\n        if (currentElement.parentElement) {\n            currentElement = currentElement.parentElement;\n        } else {\n            return false;\n        }\n    }\n\n    return false;\n}\n\nfunction canScrollHorizontal(\n    element: Element,\n    rootElement: Element,\n    scrollEnd: boolean,\n): boolean {\n    let currentElement = element;\n\n    while (currentElement !== rootElement.parentElement) {\n        if (\n            (Math.floor(currentElement.scrollLeft) > 0 && !scrollEnd) ||\n            (Math.ceil(currentElement.scrollLeft + currentElement.clientWidth) <\n                currentElement.scrollWidth &&\n                scrollEnd)\n        ) {\n            return true;\n        }\n\n        if (currentElement.parentElement) {\n            currentElement = currentElement.parentElement;\n        } else {\n            return false;\n        }\n    }\n\n    return false;\n}\n","export function containsOrAfter(current: Node, node: Node): boolean {\n    return (\n        current.contains(node) ||\n        !!(\n            // tslint:disable:no-bitwise\n            (node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING)\n        )\n    );\n}\n","export function tuiCustomEvent<T = null>(\n    name: string,\n    {bubbles = false, cancelable = false, detail = null}: CustomEventInit<T | null> = {},\n    documentRef: Document,\n): CustomEvent {\n    if (typeof CustomEvent === 'function') {\n        return new CustomEvent(name, {bubbles, cancelable, detail});\n    }\n\n    const customEvent = documentRef.createEvent('CustomEvent');\n\n    customEvent.initCustomEvent(name, bubbles, cancelable, detail);\n\n    return customEvent;\n}\n","/**\n * Gets actual target from open Shadow DOM if event happened within it\n */\nexport function getActualTarget(event: Event): Node {\n    if ('composedPath' in event) {\n        return (event as any).composedPath()[0];\n    }\n\n    return (event as any).target;\n}\n","/**\n * Gets text from data of clipboardEvent, it also works in IE and Edge browsers\n */\nexport function getClipboardDataText(\n    event: ClipboardEvent,\n    format: string = 'text/plain',\n): string {\n    return 'clipboardData' in event && event.clipboardData !== null\n        ? event.clipboardData.getData(format)\n        : (event as any).target.ownerDocument.defaultView.clipboardData.getData('text');\n}\n","/**\n * Gets closest element by selector i.e. {@link Element.closest}\n */\nexport function getClosestElement(element: Element, selector: string): Element | null {\n    const closest = Element.prototype.closest;\n\n    if (closest) {\n        return closest.call(element, selector);\n    }\n\n    const matchesSelector =\n        Element.prototype.matches || (Element.prototype as any).msMatchesSelector;\n\n    do {\n        if (matchesSelector.call(element, selector)) {\n            return element;\n        }\n\n        (element as Element | null) = element.parentElement;\n    } while (element !== null);\n\n    return null;\n}\n","export function getDocumentOrShadowRoot(node: Node): DocumentOrShadowRoot {\n    return 'getRootNode' in node &&\n        node.ownerDocument &&\n        node.ownerDocument.body.contains(node)\n        ? (node.getRootNode() as Document)\n        : node.ownerDocument!;\n}\n","import {clamp} from '@taiga-ui/cdk/utils/math';\nimport {isPresent} from '@taiga-ui/cdk/utils/miscellaneous';\nimport {getDocumentOrShadowRoot} from './get-document-or-shadow-root';\n\n/**\n * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible\n *\n * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered\n */\nexport function getElementObscurers(element: Element): ReadonlyArray<Element> | null {\n    const {ownerDocument} = element;\n\n    if (!ownerDocument || !ownerDocument.defaultView) {\n        return null;\n    }\n\n    const {innerWidth, innerHeight} = ownerDocument.defaultView;\n    const documentRef = getDocumentOrShadowRoot(element);\n    const rect = element.getBoundingClientRect();\n    const left = clamp(Math.round(rect.left) + 2, 0, innerWidth);\n    const top = clamp(Math.round(rect.top) + 2, 0, innerHeight);\n    const right = clamp(Math.round(rect.right) - 2, 0, innerWidth);\n    const bottom = clamp(Math.round(rect.bottom) - 2, 0, innerHeight);\n    const horizontalMiddle = clamp(Math.round(rect.left + rect.width / 2), 0, innerWidth);\n    const verticalMiddle = clamp(Math.round(rect.top + rect.height / 2), 0, innerHeight);\n    const elements = [\n        documentRef.elementFromPoint(horizontalMiddle, top),\n        documentRef.elementFromPoint(horizontalMiddle, bottom),\n        documentRef.elementFromPoint(left, verticalMiddle),\n        documentRef.elementFromPoint(right, verticalMiddle),\n    ];\n    const nonNull = elements.filter(isPresent);\n\n    if (!nonNull.length) {\n        return nonNull;\n    }\n\n    const filtered = nonNull.filter(el => !element.contains(el));\n\n    return filtered.length === 4 ? filtered : null;\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\n\n/**\n * Calculates offset for an element relative to it's parent several levels above\n *\n * @param host parent element\n * @param element\n * @return object with offsetTop and offsetLeft number properties\n */\nexport function getElementOffset(\n    host: Element,\n    element: HTMLElement,\n): {offsetTop: number; offsetLeft: number} {\n    tuiAssert.assert(host.contains(element), 'Host must contain element');\n\n    let {offsetTop, offsetLeft, offsetParent} = element;\n\n    while (offsetParent && offsetParent instanceof HTMLElement && offsetParent !== host) {\n        offsetTop += offsetParent.offsetTop;\n        offsetLeft += offsetParent.offsetLeft;\n        offsetParent = offsetParent.offsetParent;\n    }\n\n    return {offsetTop, offsetLeft};\n}\n","/**\n * Finds nearest parent with scroll in it\n *\n * @param element initial element\n * @param vertical flag for orientation of scroll\n */\nexport function getScrollParent(\n    element: Element | null,\n    vertical: boolean = true,\n): Element | null {\n    if (element === null) {\n        return null;\n    }\n\n    if (vertical && element.scrollHeight > element.clientHeight) {\n        return element;\n    }\n\n    if (!vertical && element.scrollWidth > element.clientWidth) {\n        return element;\n    }\n\n    return getScrollParent(element.parentElement, vertical);\n}\n","export function isCurrentTarget({target, currentTarget}: Event): boolean {\n    return target === currentTarget;\n}\n","import {getClosestElement} from './get-closest-element';\n\n/**\n * Checks if node is inside a specific selector\n *\n * @param node\n * @param selector\n * @return true if node is inside a particular selector\n */\nexport function isNodeIn(node: Node, selector: string): boolean {\n    return node.nodeType === Node.TEXT_NODE\n        ? !!node.parentElement && !!getClosestElement(node.parentElement, selector)\n        : node.nodeType === Node.ELEMENT_NODE &&\n              !!getClosestElement(node as Element, selector);\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}