import { __decorate, __param } from 'tslib';
import { DOCUMENT } from '@angular/common';
import { Inject, ElementRef, Renderer2, HostListener, Directive, NgModule } from '@angular/core';
import { containsOrAfter } from '@taiga-ui/cdk/utils/dom';
import { getNativeFocused, setNativeFocused, getClosestKeyboardFocusable, blurNativeFocused } from '@taiga-ui/cdk/utils/focus';

// @dynamic
var TuiFocusTrapDirective = /** @class */ (function () {
    function TuiFocusTrapDirective(documentRef, elementRef, renderer) {
        var _this = this;
        this.documentRef = documentRef;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.activeElement = getNativeFocused(this.documentRef);
        /**
         * This would cause currently focused element to lose focus
         * but it might cause ExpressionChanged error due to potential HostBinding.
         * Microtask keeps it in the same frame but allows change detection to run
         */
        Promise.resolve().then(function () {
            setNativeFocused(_this.elementRef.nativeElement);
        });
    }
    TuiFocusTrapDirective.prototype.onBlur = function () {
        this.renderer.removeAttribute(this.elementRef.nativeElement, 'tabIndex');
    };
    TuiFocusTrapDirective.prototype.onFocusIn = function (node) {
        if (containsOrAfter(this.elementRef.nativeElement, node)) {
            return;
        }
        var focusable = getClosestKeyboardFocusable(this.elementRef.nativeElement, false, this.elementRef.nativeElement);
        if (focusable) {
            setNativeFocused(focusable);
        }
    };
    TuiFocusTrapDirective.prototype.ngOnDestroy = function () {
        var _this = this;
        blurNativeFocused(this.documentRef);
        /**
         * HostListeners are triggered even after ngOnDestroy
         * {@link https://github.com/angular/angular/issues/38100}
         * so we need to delay it but stay in the same sync cycle,
         * therefore using Promise instead of setTimeout
         */
        Promise.resolve().then(function () {
            if (_this.activeElement instanceof HTMLElement) {
                setNativeFocused(_this.activeElement);
            }
        });
    };
    TuiFocusTrapDirective.ctorParameters = function () { return [
        { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Renderer2, decorators: [{ type: Inject, args: [Renderer2,] }] }
    ]; };
    __decorate([
        HostListener('blur')
    ], TuiFocusTrapDirective.prototype, "onBlur", null);
    __decorate([
        HostListener('window:focusin.silent', ['$event.target'])
    ], TuiFocusTrapDirective.prototype, "onFocusIn", null);
    TuiFocusTrapDirective = __decorate([
        Directive({
            selector: '[tuiFocusTrap]',
            host: {
                tabIndex: '0',
            },
        }),
        __param(0, Inject(DOCUMENT)),
        __param(1, Inject(ElementRef)),
        __param(2, Inject(Renderer2))
    ], TuiFocusTrapDirective);
    return TuiFocusTrapDirective;
}());

var TuiFocusTrapModule = /** @class */ (function () {
    function TuiFocusTrapModule() {
    }
    TuiFocusTrapModule = __decorate([
        NgModule({
            declarations: [TuiFocusTrapDirective],
            exports: [TuiFocusTrapDirective],
        })
    ], TuiFocusTrapModule);
    return TuiFocusTrapModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { TuiFocusTrapDirective, TuiFocusTrapModule };
//# sourceMappingURL=taiga-ui-cdk-directives-focus-trap.js.map
