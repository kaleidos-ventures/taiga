import { __decorate, __param } from 'tslib';
import { ɵɵdefineInjectable, Injectable, Inject, ɵɵinject, Optional, NgZone, SecurityContext, Sanitizer } from '@angular/core';
import { Observable, BehaviorSubject, fromEvent, EMPTY } from 'rxjs';
import { WINDOW, ANIMATION_FRAME } from '@ng-web-apis/common';
import { startWith, map, share, distinctUntilChanged, takeUntil } from 'rxjs/operators';
import { RouterLinkActive } from '@angular/router';
import { tuiZoneOptimized, TuiDestroyService, tuiAssert } from '@taiga-ui/cdk';
import { DomSanitizer } from '@angular/platform-browser';
import { TUI_SANITIZER, TUI_ICONS } from '@taiga-ui/core/tokens';
import { processIcon } from '@taiga-ui/core/utils/dom';

/**
 * Service for displaying hints/tooltips
 */
let TuiHintService = class TuiHintService extends Observable {
    constructor() {
        super(observer => this.hints$.subscribe(observer));
        this.hints$ = new BehaviorSubject([]);
        /**
         * TODO: v2.0
         * We need the following logic for desribedBy
         * move it into another service that can register hints and
         * manage it using TuiHintService inside
         */
        this.directives = [];
    }
    add(directive) {
        this.hints$.next([...this.hints$.value, directive]);
    }
    remove(directive) {
        this.hints$.next(this.hints$.value.filter(hint => hint !== directive));
    }
    register(directive) {
        this.directives = [...this.directives, directive];
    }
    unregister(directive) {
        this.remove(directive);
        this.directives = this.directives.filter(dir => dir !== directive);
    }
    showHintForId(id) {
        const directive = this.findDirectiveWithHintId(id);
        if (directive) {
            this.add(directive);
        }
    }
    hideHintForId(id) {
        const directive = this.findDirectiveWithHintId(id);
        if (directive) {
            this.remove(directive);
        }
    }
    findDirectiveWithHintId(id) {
        return this.directives.find(directive => directive.tuiHintId === id);
    }
};
TuiHintService.ɵprov = ɵɵdefineInjectable({ factory: function TuiHintService_Factory() { return new TuiHintService(); }, token: TuiHintService, providedIn: "root" });
TuiHintService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], TuiHintService);

// @dynamic
let TuiNightThemeService = class TuiNightThemeService extends Observable {
    constructor(windowRef) {
        const media = windowRef.matchMedia('(prefers-color-scheme: dark)');
        const media$ = fromEvent(media, 'change').pipe(startWith(null), map(() => media.matches), share());
        super(subscriber => media$.subscribe(subscriber));
    }
};
TuiNightThemeService.ctorParameters = () => [
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
];
TuiNightThemeService.ɵprov = ɵɵdefineInjectable({ factory: function TuiNightThemeService_Factory() { return new TuiNightThemeService(ɵɵinject(WINDOW)); }, token: TuiNightThemeService, providedIn: "root" });
TuiNightThemeService = __decorate([
    Injectable({
        providedIn: 'root',
    }),
    __param(0, Inject(WINDOW))
], TuiNightThemeService);

let TuiRouterLinkActiveService = class TuiRouterLinkActiveService extends Observable {
    constructor(routerLinkActive, ngZone, animationFrame$, destroy$) {
        const stream$ = routerLinkActive
            ? animationFrame$.pipe(map(() => routerLinkActive.isActive), distinctUntilChanged(), tuiZoneOptimized(ngZone), takeUntil(destroy$))
            : EMPTY;
        super(subscriber => stream$.subscribe(subscriber));
    }
};
TuiRouterLinkActiveService.ctorParameters = () => [
    { type: RouterLinkActive, decorators: [{ type: Optional }, { type: Inject, args: [RouterLinkActive,] }] },
    { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] },
    { type: TuiDestroyService, decorators: [{ type: Inject, args: [TuiDestroyService,] }] }
];
TuiRouterLinkActiveService = __decorate([
    Injectable(),
    __param(0, Optional()),
    __param(0, Inject(RouterLinkActive)),
    __param(1, Inject(NgZone)),
    __param(2, Inject(ANIMATION_FRAME)),
    __param(3, Inject(TuiDestroyService))
], TuiRouterLinkActiveService);

/**
 * Service for reusing SVGs without inlining each instance
 */
// @dynamic
let TuiSvgService = class TuiSvgService {
    constructor(tuiSanitizer, sanitizer, icons) {
        this.tuiSanitizer = tuiSanitizer;
        this.sanitizer = sanitizer;
        this.items$ = new BehaviorSubject(new Map());
        this.originals = {};
        this.define(icons);
    }
    define(icons) {
        const { value } = this.items$;
        Object.keys(icons).forEach(key => {
            this.defineIcon(key, icons[key], value);
        });
        this.items$.next(value);
    }
    getOriginal(name) {
        return this.originals[name] || null;
    }
    defineIcon(name, src, map) {
        if (map.has(name)) {
            return;
        }
        const parsed = this.parseSrc(name, src);
        if (!parsed) {
            tuiAssert.assert(false, 'Unable to parse given SVG src');
            return;
        }
        map.set(name, parsed);
        this.originals = Object.assign(Object.assign({}, this.originals), { [name]: src });
    }
    parseSrc(name, src) {
        return this.sanitize(processIcon(src, name));
    }
    sanitize(src) {
        return this.sanitizer.bypassSecurityTrustHtml((this.tuiSanitizer
            ? this.tuiSanitizer.sanitize(SecurityContext.HTML, src)
            : this.sanitizer.sanitize(SecurityContext.HTML, src)) || '');
    }
};
TuiSvgService.ctorParameters = () => [
    { type: Sanitizer, decorators: [{ type: Optional }, { type: Inject, args: [TUI_SANITIZER,] }] },
    { type: DomSanitizer, decorators: [{ type: Inject, args: [DomSanitizer,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TUI_ICONS,] }] }
];
TuiSvgService.ɵprov = ɵɵdefineInjectable({ factory: function TuiSvgService_Factory() { return new TuiSvgService(ɵɵinject(TUI_SANITIZER, 8), ɵɵinject(DomSanitizer), ɵɵinject(TUI_ICONS)); }, token: TuiSvgService, providedIn: "root" });
TuiSvgService = __decorate([
    Injectable({
        providedIn: 'root',
    }),
    __param(0, Optional()),
    __param(0, Inject(TUI_SANITIZER)),
    __param(1, Inject(DomSanitizer)),
    __param(2, Inject(TUI_ICONS))
], TuiSvgService);

/**
 * Generated bundle index. Do not edit.
 */

export { TuiHintService, TuiNightThemeService, TuiRouterLinkActiveService, TuiSvgService };
//# sourceMappingURL=taiga-ui-core-services.js.map
