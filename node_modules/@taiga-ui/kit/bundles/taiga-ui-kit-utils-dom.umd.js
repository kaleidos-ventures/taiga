(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taiga-ui/cdk')) :
    typeof define === 'function' && define.amd ? define('@taiga-ui/kit/utils/dom', ['exports', '@taiga-ui/cdk'], factory) :
    (global = global || self, factory((global['taiga-ui'] = global['taiga-ui'] || {}, global['taiga-ui'].kit = global['taiga-ui'].kit || {}, global['taiga-ui'].kit.utils = global['taiga-ui'].kit.utils || {}, global['taiga-ui'].kit.utils.dom = {}), global.cdk));
}(this, (function (exports, cdk) { 'use strict';

    /**
     * Creates a cloned range with its boundaries set at word boundaries
     *
     * @param currentRange a range to clone
     * @return modified range
     */
    function getWordRange(currentRange) {
        var range = currentRange.cloneRange();
        var startContainer = range.startContainer, startOffset = range.startOffset, endContainer = range.endContainer, endOffset = range.endOffset;
        var ownerDocument = startContainer.ownerDocument;
        if (!ownerDocument) {
            return range;
        }
        var treeWalker = ownerDocument.createTreeWalker(ownerDocument.body, NodeFilter.SHOW_TEXT, cdk.svgNodeFilter, false);
        treeWalker.currentNode = startContainer;
        do {
            var container = treeWalker.currentNode;
            var textContent = container.textContent || '';
            var content = container === startContainer
                ? textContent.substr(0, startOffset + 1)
                : textContent;
            var offset = Math.max(content.lastIndexOf(' '), content.lastIndexOf(cdk.CHAR_NO_BREAK_SPACE), content.lastIndexOf(cdk.CHAR_ZERO_WIDTH_SPACE)) + 1;
            range.setStart(container, 0);
            if (offset) {
                range.setStart(container, offset);
                break;
            }
        } while (treeWalker.previousNode());
        treeWalker.currentNode = endContainer;
        do {
            var container = treeWalker.currentNode;
            var textContent = container.textContent || '';
            var content = container === endContainer ? textContent.substr(endOffset + 1) : textContent;
            var offset = [
                content.indexOf(' '),
                content.indexOf(cdk.CHAR_NO_BREAK_SPACE),
                content.indexOf(cdk.CHAR_ZERO_WIDTH_SPACE),
            ].reduce(function (result, item) {
                return result === -1 || item === -1
                    ? Math.max(result, item)
                    : Math.min(result, item);
            }, -1);
            range.setEnd(container, textContent.length);
            if (offset !== -1) {
                range.setEnd(container, offset + textContent.length - content.length);
                break;
            }
        } while (treeWalker.nextNode());
        return range;
    }

    function scrollToElement(element, container) {
        var scrolledWidth = container.offsetWidth + container.scrollLeft;
        var elementWidth = element.offsetWidth;
        var elementX = container.scrollLeft +
            element.getBoundingClientRect().left -
            container.getBoundingClientRect().left;
        var elementDidNotFitRight = elementX + elementWidth > scrolledWidth;
        var elementDidNotFitLeft = container.scrollLeft > elementX;
        var deltaXRight = elementX + elementWidth - scrolledWidth;
        var deltaXLeft = elementX - container.scrollLeft;
        if (elementDidNotFitRight) {
            container.scrollLeft += deltaXRight;
        }
        if (elementDidNotFitLeft) {
            container.scrollLeft += deltaXLeft;
        }
    }

    /**
     * Range.setStart/set-end, except it uses offset in characters only
     */
    function setRangeOffset(range, node, offset, method) {
        var ownerDocument = node.ownerDocument;
        if (!ownerDocument) {
            return;
        }
        var treeWalker = ownerDocument.createTreeWalker(node, NodeFilter.SHOW_TEXT, cdk.svgNodeFilter, false);
        treeWalker.currentNode = node;
        while (treeWalker.nextNode()) {
            if (treeWalker.currentNode.nodeType === Node.TEXT_NODE) {
                var length_1 = treeWalker.currentNode.nodeValue
                    ? treeWalker.currentNode.nodeValue.length
                    : 0;
                if (offset > length_1) {
                    offset -= length_1;
                }
                else {
                    range[method](treeWalker.currentNode, offset);
                }
            }
        }
    }

    exports.getWordRange = getWordRange;
    exports.scrollToElement = scrollToElement;
    exports.setRangeOffset = setRangeOffset;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=taiga-ui-kit-utils-dom.umd.js.map
